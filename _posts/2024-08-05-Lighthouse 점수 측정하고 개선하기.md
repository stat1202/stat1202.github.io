---
categories: [프론트엔드, 성능]
tags: [라이트하우스, lighthouse, 성능, performance, 최적화, optimization]
---


이번 프로젝트에서 Lighthouse를 사용해 성능을 측정하고, 개선하는 경험을 했다. 하지만 Lighthouse에서 개선하라고 한 부분을 개선 했을 뿐, 해당 지표들이 어떤 의미를 가지는지에 대한 지식은 부족했다. 그래서 해당 지표들이 어떤 의미를 가지고 어떻게 개선할 수 있는지, 그리고 실제 프로젝트에서 어떻게 적용했는지 소개를 해보려고 한다.
# 1. FCP
> **First Contentful Paint**로 브라우저가 첫 번째 텍스트 또는 이미지 컨텐츠를 화면에 렌더링하는 시간을 측정한다. 사용자가 페이지 로딩을 인식하는 시점을 나타내고, 빠를수록 좋은 첫 인상을 줄 수 있다.

> **최적화 방법**
- 중요 컨텐츠를 우선적으로 로드한다.
- CSS와 JavaScript를 최적화하고, 불필요한 렌더링 차단 리소스를 제거한다.
- CDN을 사용해 컨텐츠 전송 속도를 높인다.

# 2. Speed Index
> **Speed Index**는 페이지 컨텐츠가 시각적으로 얼마나 빨리 표시되는지 측정하는 지표이다. Speed Index 값이 낮을수록 사용자는 더 빨리 페이지를 시각적으로 인식할 수 있다.

> **최적화 방법**
- 중요 컨텐츠가 빨리 로드되도록 비동기 로딩 사용
- 이미지, 비디오 같은 멀티미디어 컨텐츠 최적화
- 렌더링 차단하는 리소스 최소화

# 3. LCP
> **Largest Contentful Paint**는 페이지의 주요 컨텐츠가 렌더링되는 시간을 측정한다. LCP는 사용자에게 페이지가 거의 로드되었음을 나타내는 지표이다.

> **최적화 방법**
- 중요한 이미지, 비디오 및 텍스트 블록이 빠르게 로드되도록 최적화
- 서버 응답시간 줄이기
- 클라이언트 측 렌더링을 최소화 하고, 불필요한 자바스크립트 제거

> **주요 컨텐츠란?**
- 이미지 요소 (예: <img\> 태그)
- 비디오 포스터 이미지 (예: <video\> 요소의 포스터 이미지)
- 배경 이미지 (예: CSS background-image 속성)
- 텍스트 블록 (예: <p\> 태그 내의 텍스트)

# 4. TTI
> **Time To Iteractive** 페이지가 완전히 상호작용 가능해지는 시간을 측정한다. 사용자가 페이지를 클릭하거나 스크롤 동작 등을 할 수 있는 시점을 의미한다.

> **최적화 방법**
- 불필요한 자바스크립트 실행을 지연하거나 비동기화 한다.
- CSS와 폰트를 최적화해 초기 렌더링 성능을 개선한다.
- 서비스 워커와 같은 기술을 사용해 캐싱 전략을 개선한다.

# 5. TBT
> **Total Blocking Time**은 FCP와 TTI 사이 시간 중 페이지 메인 스레드가 차단된 시간을 측정한다. TBT가 낮을수록 사용자는 페이지와 더 빠르게 상호작용할 수 있다.

> **최적화 방법**
- 자바스크립트 코드를 최적화해 메인 스레드 차단 최소화
- 웹 워커를 사용해 무거운 작업 분리
- 중요한 작업을 나누어 작은 청크로 처리

# 6. CLS
> **Cumulative Layout Shift**는 페이지가 로딩되는 동안 발생하는 예상치 못한 레이아웃 변경의 총합을 측정한다. 낮을수록 사용자 경험에 좋다.

> **최적화 방법**
- 이미지와 비디오의 크기를 명시해 레이아웃 변경 방지
- 광고나 동적 컨텐츠가 삽입될 공간 예약
- 웹폰트를 사용해 텍스트 로딩 시 레이아웃 변경 최소화

# 실제 적용
![](/assets/img/post/2024-08-05/뉴스%20최적화%20전.png)
> 내가 프로젝트에서 실제로 구현한 페이지이다. 다른 지표들은 좋게 나왔지만 LCP가 2.3초로 높게 측정 되었다.


![](/assets/img/post/2024-08-05/뉴스%20최적화%20후.png)
최적화를 적용한 결과이다. 88점에서 99점으로 11점이 상승했다. 어떻게 이렇게 점수를 높일 수 있었을까? 내가 적용한 방법은 2가지이다.
> 1. 이미지 최적화
Next.js로 구현했기에 손쉽게 이미지를 최적화 할 수 있었다. 
```next.config.mjs```에 아래 코드를 추가했다.
```typescript
images: {
    formats: ['image/avif', 'image/webp'],
  },
```
그러면 이제 Next.js 자체에서 이미지를 avif 확장자로 우선 변경해준다.
그 다음 이미지 렌더링 크기를 조정했다.
<br>
최적화 전
![](/assets/img/post/2024-08-05/이미지%20최적화%20전.png)
<br>
최적화 후
![](/assets/img/post/2024-08-05/이미지%20최적화%20후.png)
<br>
최적화 전에는 내부 크기가 800x533px로 렌더링된 크기에 비해 과하게 큰 것을 알 수있다. 그래서 ```next/Image```의 ```sizes``` 옵션을 주어 렌더링된 크기와 비슷한 크기로 이미지 파일을 로드할 수 있도록 조정했다.
<br>
이미지 용량을 약 85% 정도 감소시켰지만, LCP 개선에서 가장 큰 부분을 차지한 로드 지연 2000ms로 여전히 해결되지는 않았다.

> 2. 폰트 최적화
팀원분과 3시간 넘게 문제점을 찾은 것 같다. 분명 LCP가 가리키는 요소는 이미지인데 어째서 개선이 되지 않는지와 같은 고민을 하면서 구글링을 하며 여러 방법을 적용했다. 그러던 중 팀원분이 이미지 크기를 모두 줄이고 성능 측정을 진행했고, 그 때 나온 LCP 개선 사항이 폰트였다.
폰트 최적화 방법을 패스트캠퍼스 강의에서 본 경험이 있어, 팀원분에게 "강의좀 보고 올게요."하고, 폰트 최적화를 적용했다.
<br>
최적화 전
![](/assets/img/post/2024-08-05/폰트%20최적화%20전.png)
<br>
최적화 후
![](/assets/img/post/2024-08-05/폰트%20최적화%20후.png)
subset을 적용해 폰트 크기를 약 92% 줄였다. 그리고 기존 폰트 대신 subset 폰트로 교체한 결과 드디어 로드 지연이 300ms로 감소했다.
LCP의 80%를 차지하던 로드 지연이 감소했으므로, 당연하게도 LCP의 성능이 급격히 상승해 99점을 받을 수 있었다.

Next를 사용하는데도 왜 ```next/font```에서 제공하는 폰트를 사용하지 않았냐면, 프로젝트 기획에서 폰트가 ```Pretendard```로 결정되었고, ```Pretendard```는 지원하지 않았다. 그래서 어쩔 수 없이 로컬 폰트를 이용해야 했다.
하지만 로컬 폰트를 사용하지 않았다면 이런 문제를 겪지 못했을 것이고, 결국에는 배웠던 지식을 실제 프로젝트에서 사용할 수 있는 좋은 경험이 되었다.
